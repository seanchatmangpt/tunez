Generating APIs Without Writing Code

In the previous chapter, we looked at making the artist catalog a lot more
user-friendly by letting users search, sort and filter artist data. This was a
big boost to Tunez’s popularity, so much so that some users are asking how
they can use the data from Tunez in their own apps.

We can give users access to a Tunez application programming interface , or API
— a way of letting their apps talk to Tunez, to fetch or modify data. APIs are
everywhere, whenever we build apps that can communicate with other apps,
we’re doing it via an API. If you’re connecting to Facebook to read a user’s
friends list, or built an app that upload photos to a image-hosting service like
Cloudinary, you’re using those services’s APIs.

Let’s look at how we can build an API for Tunez to let other apps talk to us ,
using the resources and actions we’ve defined so far.

Model Your Domain, Derive The Rest
One of the core design principles^1 of Ash is its declarative and derivable nature.
By themselves, resources are static configuration files that Ash can interpret
and generate code from. We’ve seen examples of this with code interfaces for
our actions — we declared that we should have an interface for our Artist :search
action that accepts one argument for the query text, and Ash generated the
function for us to call.

This can be taken further — Ash can generate a lot more than functions. It
can generate entire APIs around the existing resources and actions in your
app, hence the name of this chapter.

https://hexdocs.pm/ash/design-principles.html
It sounds wild, but what is an API, really? A set of functions, that map from
an input URL to a response in a format like JSON.^2 Our web UI is an API,
albeit a heavily customized one that returns HTML. An API using something
like GraphQL^3 or REST^4 is a lot more standardized. Both the incoming requests
and the outgoing responses have a very strict format to adhere to, and that
can be generated for us using Ash.

We’ll build two APIs in this chapter, using both REST and GraphQL. In a real
app you’d probably want one or the other, but we’ll show off a little bit here
and add both. Let’s go!

Building a JSON REST Interface
A REST (or RESTful) API can be generated by Ash using the ash_json_api package.
This will accept requests over HTTP, and return data formatted as JSON. As
a bonus, APIs generated with ash_json_api are compatible with the JSON:API^5
specification, and can optionally also generate OpenAPI^6 schemas, opening
up a whole world of supporting tooling options.

Setup

You can add ash_json_api to Tunez using the igniter.install Mix task:

$ mix igniter.installash_json_api

This will add a few new pieces to your app, that have a lot of power. The
additions include:

The ash_json_api Hex package, as well as its sibling dependency open_api_spex
(in mix.exs and mix.lock)
Code formatting and configuration to support a new application/vnd.api+json
media type, needed for JSON:API compatibility^7 (in config/config.exs)
A new scope in your Phoenix router to accept web requests for the /api/json/
URL (in lib/tunez_web/router.ex)
A new TunezWeb.AshJsonApiRouter module that uses AshJsonApi.Router. This will
process the web requests and return responses in the correct format (in
lib/tunez_web/ash_json_api_router.ex)
A new mix alias, to include API routes in the phx.routes output (in mix.exs)
https://stackoverflow.blog/2022/06/02/a-beginners-guide-to-json-the-data-format-for-the-internet/
https://graphql.org/
https://www.ibm.com/topics/rest-apis
https://jsonapi.org/
https://www.openapis.org/
https://jsonapi.org/format/#introduction
Chapter 4. Generating APIs Without Writing Code • 90

This takes care of a lot of the boilerplate around a REST API, leaving us to
handle the implementation of what our API should actually do.

Adding Artists to the API

What we primarily want to expose in our API is the CRUD interface for our
resources to let users manage artist and album data over the API. Each of
our resources can be exposed as a type/schema/definition and each action
on a resource exposed as an operation.

By default, the API is empty — we have to manually include each resource
and action we want to make public. To add a resource to the API, we can use
Ash’s ash.extend Mix task to extend the resource with the AshJsonApi.Resource
extension:

$ mix ash.extendTunez.Music.Artistjson_api

This will make some handy changes in our app:

AshJsonApi.Resource will be added as an extension to the Tunez.Music.Artist
resource
A default API “type” will be added to the resource, in a new json_api block
in the resource. Each record in a API response is identified by an id and
a type field,^8 the type usually being a string version of the resource name.
And because this is the first resource in the Tunez.Music domain to be configured
for AshJsonApi, the patch generator will also connect pieces in the domain:

AshJsonApi.Domain will be added as an extension to the Tunez.Music domain
And the Tunez.Music domain will be added to the list of domains configured
in the TunezWeb.AshJsonApiRouter module.
You could make all the changes yourself manually, but there’s a few moving
parts there and it can be easy to miss a connection. The generators are a
convenient way of making sure everything is set up as it should be.

Next, to make the actions on the Artist resource available in the API, we need
to set up routes for them. Like code interfaces, this can be done either on the
resource or the domain. However, to keep the domain as the solid boundary
between our domain model and the outside world, we’ll add them on the
domain.

https://jsonapi.org/format/#document-resource-object-identification
Building a JSON REST Interface • 91

In a new top-level json_api block in the Tunez.Music domain module, configure
the routes using the DSL provided by AshJsonApi:^9
04/lib/tunez/music.ex
defmodule Tunez.Music do
# ...
➤ json_api do
➤ routes do
➤ base_route "/artists" , Tunez.Music.Artist do
➤ get :read
➤ index :search
➤ post :create
➤ patch :update
➤ delete :destroy
➤ end
➤ end
➤ end
end
This code will connect a GET request to read a single artist by a given ID to
the read action of the Tunez.Music.Artist resource, automatically applying the
correct filter. A POST request will be connected to the create action, and so on.
As Ash also holds introspectability as one of its core design principles,^10 you
can fetch a list of generated routes and the actions they connect to in iex using
AshJsonApi.Domain.Info:
iex(1)> AshJsonApi.Domain.Info.routes(Tunez.Music)
|> Enum.map(fnr -> {r.route, r.method,r.resource,r.action}end)
[
{"/artists/:id",:get,Tunez.Music.Artist,:read},
{"/artists",:get,Tunez.Music.Artist,:search},
{"/artists",:post,Tunez.Music.Artist,:create},
{"/artists/:id",:patch,Tunez.Music.Artist,:update},
{"/artists/:id",:delete,Tunez.Music.Artist,:destroy}
]
You can also see them when running the phx.routes Mix task, to list all of the
routes available in your application:
$ mix phx.routes
«routesdefinedin the Phoenix router»
GET /api/json/artists/:id AshJsonApi.Resource.Route:get
GET /api/json/artists AshJsonApi.Resource.Route:index
POST /api/json/artists AshJsonApi.Resource.Route:post
PATCH /api/json/artists/:id AshJsonApi.Resource.Route:patch

https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-domain.html#json_api-routes
10.https://hexdocs.pm/ash/design-principles.html
Chapter 4. Generating APIs Without Writing Code • 92

DELETE /api/json/artists/:id AshJsonApi.Resource.Route:delete
So how can we actually use the API? For GET requests, you can access the
endpoints provided in a browser like any other URL. Alternatively, you could
use a dedicated API client app such as Bruno,^11 shown here making a GET
request to /api/json/artists:

Don’t forget the custom headers!
While not strictly required for GET requests, you should configure
your API client to add the correct Content-Type and Accept headers
when making any requests to your API. These can usually be set
on either the individual request level or the collection level,
depending on your API client.
The value for both Content-Type and Accept headers should be applica-
tion/vnd.api+json.
The /api/json section of the URL matches the scope that our AshJsonApi router
is mounted in, the Phoenix router, and /artists matches the base route for the
Tunez.Music.Artist resource, meaning this request will connect to the search action
of the resource.

The action accepts a query argument that can be passed in as a query string
parameter, and the search results are returned in a neat JSON format. Links

11.https://www.usebruno.com/

Building a JSON REST Interface • 93

for pagination are automatically included, because the action supports pagi-
nation. And we barely needed to lift a finger!
What data gets included in API responses?
You might notice that some attributes are missing in the API response — the
artist name is shown, but the biography and previous_names are missing, as are
the aggregates for album_count, cover_image_url and latest_album_year_released that we
added in the last chapter.
This is because only public attributes (attributes that are specifically marked
public?:true) are returned in API queries, by default. This is for security reasons
— if all attributes were included by default, it would be really easy to acciden-
tally leak information as you add more data to your resources, if you didn’t
also explicitly remove them from your API.
Some of the attributes are already public, such as those we used for sorting
in the previous chapter. To add biography and previous_names to the API response,
you can also mark them as public?:true in the Tunez.Music.Artist resource:
04/lib/tunez/music/artist.ex
attributes do
# ...
attribute :biography , :string do
➤ public?true
end
attribute :previous_names , { :array , :string } do
default[]
➤ public?true
end
# ...
end
Aggregates are a little different. For this usage, they are not treated like every
other attribute, and aren’t included by default even if they’re public. This is
because calculations and aggregates can be computationally expensive, and
if they aren’t specifically needed by users of the API, you can save time and
effort by not calculating and returning them.
There are still two ways that you can make calculations and aggregates visible
in your API:

If you do want them to be calculated and returned by default, you can
use the default_fields config option, eg. default_fields[:id, :name, :biography,
:album_count]. This can be set at the resource level,^12 to apply any time an
12.https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-resource.html#json_api-default_fields
Chapter 4. Generating APIs Without Writing Code • 94

instance of the resource is returned in a response, or for any specific API
route (either in the domain^13 or in a resource.)^14 This will replace the
default “return all public attributes” behaviour, though, so you’ll have to
list all fields that should be returned by default, including any public
attributes.
Alternatively, part of the JSON:API spec^15 states that users can request
which specific fields they want to fetch as part of their API request. Our
API is JSON:API-compliant, so users can add the fields query string
parameter and list only the fields they need in a comma-separated list.
The fields can be any public fields, including aggregates and calculations,
so a URL like http://localhost:4000/api/json/artists?fields=name,album_count would
return only names and the number of albums for each artist in the search
results.
Creating artist records

We won’t cover every endpoint we created, but it’s worth a quick look at how
data can be created, as well as how it can be read.

As our introspection showed earlier, we can make POST requests to the same
URL we used for searching, to access the create action of our resource. We
can post a JSON object in the format specified in the JSON:API specification,^16
containing the content for the artist record to be created.

13.https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-domain.html#json_api-routes-base_route-get-default_fields
14.https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-resource.html#json_api-routes-get-default_fields
15.https://jsonapi.org/format/#fetching-sparse-fieldsets
16.https://jsonapi.org/format/#crud-creating

Building a JSON REST Interface • 95

In your Phoenix server logs, you can see the create request being handled by
the AshJsonApiRouter module and processed:

[info]POST/api/json/artists
[debug]ProcessingwithTunezWeb.AshJsonApiRouter
Parameters:%{"data"=> %{"attributes" => %{"biography"=> "Some
Content","name"=> "My New Artist"},"type"=> "artist"}}
Pipelines:[:api]
INSERTINTO"artists"("id","name","biography","inserted_at",
"previous_names","updated_at")VALUES($1,$2,$3,$4,$5,$6)RETURNING
"updated_at","inserted_at","previous_names","biography","name","id"
[ «uuid» , "My New Artist","SomeContent", «timestamp» , [], «timestamp» ]

Because this API endpoint connects to the create action in our Tunez.Music.Artist
resource, it accepts all of the same data as the action does. Posting additional
data (e.g., an attribute that the action doesn’t accept or a non-existent
attribute) or invalid data (e.g., a missing required field) will return an error
message, and the record won’t be created.

Other requests can be made in a similar way — a PATCH request to update an
existing artist, and a DELETE request to delete an artist record.

Adding Albums to the API

We can add album management to the JSON API in much the same way we
added artists, by extending the Tunez.Music.Album resource:

$ mix ash.extendTunez.Music.Album json_api

And adding our routes in the json_api block in the domain:

Chapter 4. Generating APIs Without Writing Code • 96

04/lib/tunez/music.ex
json_api do
routes do
# ...
➤ base_route "/albums" , Tunez.Music.Album do
➤ post :create
➤ patch :update
➤ delete :destroy
➤ end
end
end
This closely resembles the web UI. We don’t have an API endpoint to list all
albums, but we do have endpoints to manage individual album records. This
will create URLs like /api/json/albums and /api/json/albums/:album_id, with various
HTTP methods to connect to the different actions in the resource.
Because we’re not in the web UI, though, we don’t have the nice pre-filled
hidden artist ID when submitting a HTTP request to create an album — we
need to provide a valid one with the attributes of the album to be created,
like this:
{
"data" : {
"type" : "album" ,
"attributes" : {
"name" : "NewAlbum" ,
"artist_id" : [ a-valid-uuid ],
"year_released" : 2022
}
}
}
As part of this, we can also mark some of the attributes on the Tunez.Music.Album
resource as public?:true, such as name, year_released, and cover_image_url, so they
can be returned in API responses.
04/lib/tunez/music/album.ex
attributes do
uuid_primary_key :id
attribute :name , :string do
allow_nil?false
➤ public?true
end
attribute :year_released , :integer do
allow_nil?false
➤ public?true
end

Building a JSON REST Interface • 97

attribute :cover_image_url , :string do
➤ public?true
end
# ...
There’s just one part we’re missing now — listing an artist’s albums.

Showing albums for a given artist
The JSON:API spec allows for two methods of fetching related resources^17 for
a given resource. We’ll cover both methods; you can choose the one that suits
you when building your own APIs.
Both methods require the relationship to be public to be accessible over the
API, so you’ll need to mark it as public?:true in Tunez.Music.Artist:
04/lib/tunez/music/artist.ex
relationships do
has_many :albums , Tunez.Music.Album do
sort year_released::desc
➤ public?true
end
end

Including related records
This is the easiest way to provide relationship data, and it mirrors what we
see in the web UI when we view an Artist profile page. You can allow related
records to be included when fetching the parent resource — returning the
artist record, and their albums, in one request. This is convenient for con-
sumers of the API as they only need to make a single request, but the
responses can be large and they may overfetch data.
To enable this in our API, edit the json_api block in the Tunez.Music.Artist resource
to list which relationships can be included from this resource:
04/lib/tunez/music/artist.ex
json_api do
type "artist"
➤ includes[ :albums ]
end
You’ll then be able to fetch album data by adding include=albums to the query
string of any request for artist data, such as http://localhost:4000/api/json/
artists?query=cove&include=albums. The response will have a list of record identifiers
under the relationships key of the fetched data, and then a separate list of the

17.https://jsonapi.org/format/#fetching-relationships
Chapter 4. Generating APIs Without Writing Code • 98

full records under the top-level included key. The format is a little quirky, but
it’s the JSON:API way!

Linking to a list of related records

For a different approach, you can return a link to fetch relationship data via
a separate related^18 route in your domain, and also specify which action should
be used when fetching the related data.

04/lib/tunez/music.ex
base_route "/artists" , Tunez.Music.Artist do
# ...
related :albums , :read , primary?: true
end

This will add a related relationship link to the response when generating any
artist API response:

{
"data" : {
// ...
"relationships" : {
"albums" : {
"links" : {
"related" : "http://localhost:4000/api/json/artists/«id»/albums"
}
// ...

Accessing the related URL will provide a list of the related records, in JSON
format:

{
"data" : [
{
"attributes" : {
"name" : "Shadowsof Catnip" ,
"year_released" : 2023,
"cover_image_url" : "/images/albums/zombie_kittens/shadows_of_catnip.png" ,
// ...

Which is great! Now we’ve got all the same functionality from our web UI,
accessible over a JSON API. As we make further changes to our actions to
add more functionality, they’ll all automatically flow through to our API end-
points as well.

Now how can we get the word out about Tunez’s fantastic new API?

18.https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-domain.html#json_api-routes-base_route-related

Building a JSON REST Interface • 99

We can auto-generate some documentation that we can share publicly to
show people how to integrate with the API really easily!
Generating API documentation with OpenApiSpex
When we installed AshJsonApi, it also added a package called open_api_spex^19
to our mix.exs file, and this is how we can generate OpenAPI specifications
automatically for our API. We don’t have to do anything to set it up — the
AshJsonApi installer did so when it created the JSON API router in
lib/tunez_web/ash_json_api_router.ex:
04/lib/tunez_web/ash_json_api_router.ex
defmodule TunezWeb.AshJsonApiRouter do
use AshJsonApi.Router,
domains: [Module.concat([Tunez.Music])],
➤ open_api:"/open_api"
end
This one line of code will give you a full OpenAPI specification document at
the provided route, http://localhost:4000/api/json/open_api by default.
We can use this specification document with any tool or library that works
with OpenAPI (and there are many!)^20 One that OpenApiSpex provides support
for out of the box is Swagger UI,^21 to generate full documentation for our API
and even let users try out endpoints directly from the docs.
OpenApiSpex’s SwaggerUI plug has already been set up in our router, in
lib/tunez_web/router.ex:
04/lib/tunez_web/router.ex
scope "/api/json" do
pipe_through[ :api ]

➤ forward "/swaggerui" ,
➤ OpenApiSpex.Plug.SwaggerUI,
➤ path:"/api/json/open_api" ,
➤ default_model_expand_depth: 4

forward "/" , TunezWeb.AshJsonApiRouter
end
This sets up the /api/json/swaggerui URL, with a full set of Swagger UI API docu-
mentation:
19.https://hexdocs.pm/open_api_spex/
20.https://tools.openapis.org/
21.https://swagger.io/tools/swagger-ui/
Chapter 4. Generating APIs Without Writing Code • 100

Totally for free! And it’ll stay up to date as you update your API, adding or
updating resources or actions.

If Swagger UI isn’t to your liking, Redoc^22 is a good alternative. It can be
installed in your app via the redoc_ui_plug^23 Hex package, and configured in
your Phoenix router in a very similar way to Swagger UI.

And if you decide you don’t want the documentation after all, you only need
to remove the SwaggerUI plug from your router.

Customizing the generated API

Now that we have a great overview of our API, and we can see it the way a
user would, we can see some places that it can be improved. These certainly
aren’t the only ways, but they’re low-hanging fruit that will give quick wins.

Adding informative descriptions

While it’s amazing that we can get all this for free, some of the defaults in the
generated content can be a bit lacking. Our API probably shouldn’t be called
“Open API Specification”. And AshJsonApi doesn’t know what we really mean
when we say “Get artists”, so the default description of the search API endpoint
is “/artists operation on artist resource”. Not too great.

22.https://github.com/Redocly/redoc
23.https://hexdocs.pm/redoc_ui_plug/index.html

Building a JSON REST Interface • 101

Ash allows us to add description metadata in a few different places, that will
be picked up by the OpenAPI schema generator and added to the documen-
tation. This includes:
A description for a resource as a whole. This can be added as part of a
top-level resource block, such as this in Tunez.Music.Artist:
defmodule Tunez.Music.Artist do
use Ash.Resource,...
resource do
description "A personor group of peoplethatmakesand releasesmusic."
end
A description for an action, or argument for an action, in a resource.
These can be added in the action declaration itself, such as:
read :search do
description "ListArtists,optionallyfilteringby name."
argument :query , :ci_string do
description _"Returnonlyartistswithnamesincludingthe givenvalue."
..._
As a nice bonus, these descriptions should be picked up by any Elixir-related
language server packages in your text editor, such as ElixirLS or elixir-tools
in VSCode.
Basic information that is OpenAPI-specific, such as the name of the API, can
be customized via options to use AshJsonApi.Router, in your JSON API router
module. If you need to make more specific changes, you can also add a modi-
fy_open_api hook function,^24 to be called when generating the OpenAPI spec.
This function will have access to the whole generated spec, and there are a
lot of things^25 that can be changed or overwritten, so be careful!
04/lib/tunez_web/ash_json_api_router.ex
defmodule TunezWeb.AshJsonApiRouter do
use AshJsonApi.Router,
domains: [Module.concat([Tunez.Music])],
open_api:"/open_api" ,
➤ open_api_title:"TunezAPI Documentation" ,
➤ open_api_version: to_string(Application.spec( :tunez , :vsn ))
end
Once you’ve made any changes like descriptions, refreshing the Swagger UI
docs will immediately reflect the changes, and they’re looking a lot better now.

24.https://hexdocs.pm/ash_json_api/open-api.html#customize-values-in-the-openapi-documentation
25.https://hexdocs.pm/open_api_spex/OpenApiSpex.OpenApi.html#t:t/0
Chapter 4. Generating APIs Without Writing Code • 102

Removing unwanted extras
Looking through the docs carefully shows that our API can actually do a little
bit more than we thought. Expanding the section for GET /api/json/artists, our
artist search, shows the endpoint will allow data to be filtered via a filter
parameter in the URL. This is pretty cool, but we already have our own spe-
cific filtering set up, to search artists by name. So while it sounds like a waste,
we’ll disable the generated filtering for parity with the web interface.
AshJsonApi provides both generated filtering and sorting of data, for any index
actions in our API router. These can be disabled either at the resource level
or per-action. For Tunez, we want to keep the generated sorting of artists
because we allow that via the web, but disable the generated filtering. We can
do that with the derive_filter? config option^26 in the Tunez.Music.Artist resource:
04/lib/tunez/music/artist.ex
json_api do
type "artist"
includes[ :albums ]
➤ derive_filter?false
end
And that’s our JSON REST API, fully complete! It packs a lot of punch, for
not a lot of code. We didn’t have to write any endpoints, generate any JSON,
worry about error handling — everything is handled by AshJsonApi, which
generates API endpoints and controllers to connect the actions in our resources
to the outside world. It’s pretty nifty.
If JSON and REST aren’t to your liking, maybe you’re in the GraphQL camp.
We can build a GraphQL API for Tunez in a very similar way!

Building a GraphQL Interface
A GraphQL API can be generated by Ash using the ash_graphql package. It’s
built on top of the excellent absinthe^27 library, so it’s rock-solid and ready for
production use. This will create a standard GraphQL endpoint, accepting GET
requests over HTTP using GraphQL syntax and returning JSON responses.
GraphQL APIs are a little more flexible than REST APIs — though with the
JSON:API specification, the gap is smaller than you might think. We won’t
debate the pros and cons of each type of API here, but both approaches can
create well-defined, well-structured, and well-documented interfaces for your
users to work with.
26.https://hexdocs.pm/ash_json_api/dsl-ashjsonapi-resource.html#json_api-derive_filter?
27.https://hexdocs.pm/absinthe/
Building a GraphQL Interface • 103

Setup

You can add ash_graphql to Tunez using the igniter.install Mix task:

$ mix igniter.installash_graphql

This will add a few new pieces to your app, that have a lot of power. The
changes include:

A new graphql pipeline and scope in your Phoenix router, to accept requests
for both /gql, the GraphQL endpoint, and /gql/playground, a GraphiQL API
client (in lib/tunez_web/router.ex)
A new TunezWeb.GraphqlSchema module, that uses AshGraphql and Absinthe.Schema
and is seeded with a sample runnable query (in lib/tunez_web/graphql_schema.ex)
A new TunezWeb.GraphqlSocket module connected in TunezWeb.Endpoint, to support
GraphQL subscriptions (in lib/tunez_web/graqhql_socket.ex)
Code formatting and configuration for Absinthe to support requests made
with the application/graphql media type (in lib/tunez_web/endpoint.ex)
This takes care of all of the boilerplate around setting up a GraphQL API.
After restarting your Phoenix server, you can test out the GraphiQL playground
by accessing http://localhost:4000/gql/playground — there isn’t a lot to see there at
the moment, but we do have a generated schema with the sample query that
AshGraphql provides when no other queries are present. Hello, AshGraphql!

Now we can look at what the API needs to actually do.

Adding Artists to the API

What we primarily want to expose in our GraphQL API is the CRUD interface
for our resources, to let users manage artist and album data over the API.
Each of our resources can be exposed as a type, and each action on a resource
exposed as either a query or a mutation.

By default, the API is empty — we have to manually include each resource
and action that we want to make public. To add a resource to the API, we can
use Ash’s ash.extend Mix task to extend the resource with the AshGraphql.Resource
extension:

$ mix ash.extendTunez.Music.Artistgraphql

This will make some handy changes to our app:

AshGraphql.Resource will be added as an extension to the Tunez.Music.Artist
resource
Chapter 4. Generating APIs Without Writing Code • 104

A default GraphQL type will be added to the resource, in a new graphql
block in the resource. This is usually a simplified atom version of the
resource name.
And because this is the first resource in the Tunez.Music domain to be configured
for AshGraphql, the patch generator will also connect pieces in the domain:

AshGraphql.Domain will be added as an extension to the Tunez.Music domain
And the Tunez.Music domain will be added to the list of domains configured
in the TunezWeb.GraphqlSchema module.
You could make all the changes yourself manually, but there’s a few moving
parts there and it can be easy to miss a connection. The generators are a
convenient way of making sure everything is set up as it should be.

Next, to make the actions on the Artist resource available in the API, we need
to create queries and mutations for them. Like code interfaces, this can be
done either on the resource or the domain, but to keep the domain as the
solid boundary between our domain model and the outside world, we’ll add
them on the domain.

In the top-level graphql block defined in the Tunez.Music domain model, we can
add queries for read actions of our Artist resource. AshGraphql provides
macros like get and list^28 for this, which describe what kind of responses we
expect from the queries.

04/lib/tunez/music.ex
defmodule Tunez.Music do
# ...
graphql do
queries do
get Tunez.Music.Artist, :get_artist_by_id , :read
listTunez.Music.Artist, :search_artists , :search
end
end
end

This will create GraphQL queries named getArtistById, connecting to the read
action of the Tunez.Music.Artist resource and automatically applying an ID filter;
and searchArtists connecting to the search action.

We can do the same for the non-read actions in our resource, which will all
be mutations in the API:

28.https://hexdocs.pm/ash_graphql/dsl-ashgraphql-domain.html#graphql-queries

Building a GraphQL Interface • 105

04/lib/tunez/music.ex
graphql do
# ...
mutations do
createTunez.Music.Artist, :create_artist , :create
updateTunez.Music.Artist, :update_artist , :update
destroyTunez.Music.Artist, :destroy_artist , :destroy
end
end

This gives us a lot out of the box. In the GraphiQL playground, expanding
the Schema tab now shows the queries and mutations we just defined, and
they’re fully-typed — a getArtistById query will return an Artist type, with all
public attributes of the resource also typed and available to be requested. We
can run any query, and fetch data in the shape we want.

The search action accepts a query argument, which means that the generated
searchArtists query also accepts a query argument. Because the action also sup-
ports pagination, the request and response both support pagination, and it’s
all right there in the generated types. We barely needed to lift a finger!

What data gets included in API responses?

If you skipped over the JSON API section because GraphQL is much more
interesting, you might be surprised to see that fields like biography and previous-
Names aren’t defined in the GraphQL Artist type.

It was hinted at in the previous section, but it’s really important to note that
only public attributes (attributes that are specifically marked public?:true) can
be requested and returned in GraphQL responses. This is for security reasons
— if all attributes were included by default, it would be really easy to acciden-
tally leak information as you add more data to your resources, if you didn’t
also explicitly remove them from your API.

Chapter 4. Generating APIs Without Writing Code • 106

By adding public?true to those attributes in the Tunez.Music.Artist resource:
04/lib/tunez/music/artist.ex
attributes do
# ...
attribute :biography , :string do
➤ public?true
end
attribute :previous_names , { :array , :string } do
default[]
➤ public?true
end
# ...
end
They’ll then be added to the GraphQL Artist type and can be requested like
any other field.
Aggregates and calculations must also be marked as public?true if you want to
make them accessible in the API.

Creating artist records
We won’t cover every operation we created, but it’s worth a quick look at how
data can be created, as well as how it can be read.
Expanding the Schema tab in the playground shows that we can call a
mutation named createArtist for creating new Artist records. Because it connects
to the create action in the Tunez.Music.Artist resource, the attributes the action
accepts is matched by the typing of the input to the mutation.
In your Phoenix server logs, you can see the mutation being handled by
Absinthe using the TunezWeb.Schema module, and processed:
[debug]ABSINTHEschema=TunezWeb.Schemavariables=%{}
---
mutation{
Building a GraphQL Interface • 107

createArtist(input:{
name:"Unleashthe Rangers",
biography:"A greatCanadianband"
}) {
errors{ fieldsmessage}
result{ namealbumCount}
}
}
---
[debug]QUERYOK source="artists"db=2.9ms
INSERTINTO"artists"("id","name","biography","inserted_at","previous_names",
"updated_at")VALUES($1,$2,$3,$4,$5,$6)RETURNING"updated_at","inserted_at",
"previous_names","biography","name","id"[ «uuid» , "Unleashthe Rangers","A
greatCanadianband", «timestamp» , [], «timestamp» ]
If the submitted data passes the input type checking, but fails resource vali-
dation (such as an empty name value), the mutation will return a nicely typed
error message and the record won’t be created. And because the action and
mutation will return the record being created, on success, we can use all the
usual GraphQL ideas of requesting only the fields we need in the response.
Adding Albums to the API
We can add album management to the GraphQL API in much the same way
we added artists, by extending the Tunez.Music.Album resource:
$ mix ash.extendTunez.Music.Album graphql
And adding our mutations to the graphql block in the domain:
04/lib/tunez/music.ex
graphql do
mutations do
# ...
➤ createTunez.Music.Album, :create_album , :create
➤ updateTunez.Music.Album, :update_album , :update
➤ destroyTunez.Music.Album, :destroy_album , :destroy
end
end
This closely resembles the web UI. We don’t have a query to list all albums,
but we do have mutations like createAlbum and updateAlbum to manage individual
album records. Mutations for existing records have their arguments split into
id, for the ID of the artist/album to be updated, and input for the data to update
the record with.
Because we’re not in the web UI, though, we don’t have the nice pre-filled
hidden artist ID when submitting a HTTP request to create an album — we

Chapter 4. Generating APIs Without Writing Code • 108

need to provide a valid one with the attributes of the album to be created,
like this:
mutation {
createAlbum(input:{ name: "NewAlbumName" ,
artistId:[an - artist - uuid],
yearReleased: 2022
}) {
result{ id }
}
}
There’s just one part we’re missing — listing an artist’s albums.
Showing albums for a given artist
If you’ve followed the JSON API section of this chapter, you may have already
made the changes necessary to get this working.
By adding two resources with an existing relationship to our API, the flexible
nature of GraphQL means that we’ll automatically be able to load related
records — as long as the relationship is public. A relationship is just another
field to GraphQL, we don’t need to do anything fancy to support them other
than making the relationship public. We can do this by adding the option
public?true to the relationship, in the Tunez.Music.Artist resource:
04/lib/tunez/music/artist.ex
relationships do
has_many :albums , Tunez.Music.Album do
sort year_released::desc
➤ public?true
end
end
This will add the albums field to the Artist type in the GraphQL API, letting you
load related albums anywhere an artist is loaded. Super nifty!
Note that privacy settings on relationships are one way — to be able to load
a related artist for an album in the API, you would also need to make the artist
relationship in the Tunez.Music.Album resource public.

Customizing the generated API
With introspection in the GraphiQL playground, we now have a great overview
of our API and we can see it the way a user might. We can also see that there
are a few places it can be improved upon — a lot of it was covered in Customiz-
ing the generated API, on page 101 for the JSON API, but it applies equally
here for GraphQL.
Building a GraphQL Interface • 109

Adding informative descriptions

While it’s amazing that we can get all the functionality in our API basically
for free, some of the defaults can be a bit lacking. While query and mutation
names are usually pretty self-explanatory, sometimes we want to add some
more details, or be explicit about what a query argument is when searching
artists. Ash allows us to add description metadata to our app in a few different
places, that will be picked up by the GraphQL schema generator and added
to the documentation. This includes:

A description for a resource as a whole. This can be added as part of a
top-level resource block, such as this in Tunez.Music.Artist:
defmodule Tunez.Music.Artist do
use Ash.Resource,...
resource do
description "A personor group of peoplethatmakesand releasesmusic."
end

A description for an action, or argument for an action, in a resource.
These can be added in the action declaration itself, such as:
read :search do
description "ListArtists,optionallyfilteringby name."
argument :query , :ci_string do
description _"Returnonlyartistswithnamesincludingthe givenvalue."

..._
As a nice bonus, these descriptions should be picked up by any Elixir-related
language server packages in your text editor, such as ElixirLS or elixir-tools
in VSCode. And if you extend your API in future, such as adding a REST
JSON API, the same descriptions will be used to improve both.

Removing unwanted extras

Looking through the schema carefully, shows that our API can actually do a
little bit more than we thought. Expanding the section for the searchArtists query
shows that it also accepts arguments named filter, for filtering data, and sort
for sorting data. The sort option will let us sort on any public attribute, either
ascending or descending. And the filter will let us write complex conditions
using greaterThan, lessThanOrEqualTo, ilike, notEq comparisons and so on, and then
combine them with and, or and not clauses. And AshGraphql will generate this
for any list action in our API, for free.

It’s customizable, too. Our searchArtists query already has a query argument to
filter by name, so we probably don’t want to be able to filter on that in the filter

Chapter 4. Generating APIs Without Writing Code • 110

too. Some fields also don’t make too much sense to filter on, like biography. To
customize the list of fields that we can filter on, we can add the filterable_fields
config option^29 to our graphql block, in the Tunez.Music.Artist resource:
04/lib/tunez/music/artist.ex
graphql do
type :artist
➤ filterable_fields[ :album_count , :cover_image_url , :inserted_at ,
➤ :latest_album_year_released , :updated_at ]
end
We’ve removed the values that don’t make sense, but we’d still allow users
to search by name and also apply filters like:

artists that don’t have a cover image URL ({ coverImageUrl:{ isNil: true } })
artists that haven’t released an album since 2010 ({ latestAlbumYearReleased:
{ lessThan:2010 } })
artists that were added to Tunez in the last week ({ insertedAt: { greaterThan:
"2024-07-14T17:03:00Z"} }) (insert your own timestamp)
That’s pretty powerful!
If you wanted to take the nuclear option and disable the automatic filtering
or sorting, you can also do that with the derive_filter? and derive_sort? options in
your resource - set them to false.
And that’s the our GraphQL API, fully done up to match the functionality of
our web UI. It’s pretty powerful, given how little code we needed to write to
support it. We didn’t have to define our own GraphQL resolvers, or types, or
worry about error handling — everything is handled by AshGraphql. Awesome!
We’ll be revisiting our two APIs over the rest of this book, as we add more
functionality to Tunez — we want to keep full feature parity with the web,
and we also want to see if growing the API organically over time will be difficult
to do. In the meantime, we’ll look at something a bit different.
Some bad actors have started polluting Tunez with bad data, oh no! This
won’t do! Tunez has to be the best, most accurate source of high-quality
information — and that means locking down certain types of access to only
people that we trust to not do anything dodgy. Before we can start limiting
access, though, we need to know who people are, and that means some kind
of authentication process. Onward march!
29.https://hexdocs.pm/ash_graphql/dsl-ashgraphql-resource.html#graphql-filterable_fields
Building a GraphQL Interface • 111

CHAPTER 5
